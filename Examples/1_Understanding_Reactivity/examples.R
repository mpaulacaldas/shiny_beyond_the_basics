# Understanding Reactivity

library(shiny)

# --- Reactive vs. Non-reactive Programming ------------------------------------

# Non-reactive
n <- 1000
hist(rnorm(n))
n <- 2000  # nothing happens to the plot

# Reactive
ui_01 <- fluidPage(
  sliderInput("n", "Generate n randoms", 
              min = 100, max = 2000, value = 1000, step = 100),
  plotOutput("histogram")
)

server_01 <- function(input, output) {
  output$histogram <- renderPlot({
    hist(rnorm(input$n))
  })
}
shinyApp(ui_01, server_01)


# --- Adding a Conductor -------------------------------------------------------
# Sharing a calculation between multiple outputs
ui_02 <- fluidPage(
  # Input
  sliderInput("n", "Generate n randoms", 
              min = 100, max = 2000, value = 1000, step = 100),
  plotOutput("histogram"),
  verbatimTextOutput("textSummary")
)

server_02 <- function(input, output) {
  
  # Conductor (a reactive expression)
  normData <- reactive({
    rnorm(input$n)
  })
  # The reactive caches the values generated by rnorm()
  
  # Outputs
  output$histogram <- renderPlot({
    hist(normData())
    # If you forget the parenthesis, you'll get an error 'Object of type closure
    # is not subsettable...'
  })
  output$textSummary <- renderPrint({
    summary(normData())
  })
}
shinyApp(ui_02, server_02)

# Using a conductor to save processing
ui_03 <- fluidPage(
  sliderInput("n", "Generate n randoms", 
              min = 100, max = 2000, value = 1000, step = 100),
  selectInput("colour", "Select a colour",
              choices = c("orange", "blue", "green")),
  
  plotOutput("histogram")
)
server_03 <- function(input, output) {
  # Conductor
  normDataSlow <- reactive({
    Sys.sleep(3)  # sleep for 3 seconds (simulating a slow process)
    rnorm(input$n)
  })
  # Output
  output$histogram <- renderPlot({
    hist(normDataSlow(), col = input$colour)
  })
}
shinyApp(ui_03, server_03)


# --- Reactive vs. Observe -----------------------------------------------------
# What happens when we click Go?
ui_04 <- fluidPage( 
  actionButton("go", "Go!")
)
server_04 <- function(input, output) {
  reactive({
    message(paste("The Go button has the value", input$go))
  })
}
shinyApp(ui_04, server_04)  # Nothing

# observe
ui_05 <- fluidPage( 
  actionButton("go", "Go!")
)
server_05 <- function(input, output) {
  observe({
    message(paste("The Go button has the value", input$go))
  })
}
shinyApp(ui_05, server_05)  # Something!


# --- Making Our Own Inputs ----------------------------------------------------

ui_06 <- fluidPage(
  sliderInput("n", "Generate n randoms", 
              min = 100, max = 2000, value = 1000, step = 100),
  plotOutput("histogram"),
  textOutput("lastUpdated")
)

server_06 <- function(input, output) {
  
  rv <- reactiveValues(time = Sys.time())
  
  output$histogram <- renderPlot({
    hist(rnorm(input$n))
  })
  
  output$lastUpdated <- renderText({
    paste("Inputs were last updated at",  
          format(rv$time, format = "%d/%m/%Y %H:%m:%S"))
  })
  
  observe({
    tmp <- input$n  # take a dependency on input$n
    rv$time <- Sys.time()
  })
}
shinyApp(ui_06, server_06)
